# 接入 openai 搭建一个聊天网站

## 需求

1. 支持聊天，流式返回聊天内容
2. 数据库存储聊天记录

满足以上需求需要选择以下技术栈，并在各个技术栈做重要功能的实现

### react

1.  openai 返回的消息除了文本还有图片，和代码块，为了展示这些类型的消息，openai 是用 markdwon 的格式返回的，前端需要做 markdwon 格式消息的展示，这里用的`marked`

    ```typescript
    // 这里是代码块高亮的插件
    const plugin = markedHighlight({
      langPrefix: 'hljs language-',
      highlight(code, lang) {
        if (!code && !lang) {
          return '';
        }
        if (!lang) {
          return code;
        }
        const language = hljs.getLanguage(lang) ? lang : 'plaintext';
        const codeStr = hljs.highlight(code, { language }).value;
        return codeStr;
      },
    });
    marked.use(plugin);

    marked.use({
      // 处理<br>换行
      breaks: true,
    });
    // 使得marked支持XHTML，并且使标签自动闭合
    marked.use(markedXhtml());
    // 解析邮箱的插件
    marked.use(mangle());
    // 转译字符插件，防止XSS攻击，等等
    marked.use({
      renderer: {
        html(html) {
          // 转译，防止XSS
          return he.encode(html);
        },
        text(text) {
          return text.replace(/ /g, '&nbsp;');
        },
      },
    });
    ```

2.  聊天的消息是流式返回的本身可以使用 EventSource 来接收 SSE,但是 EventSource 不直接支持自定义请求头，改用了 fetch 支持接收 sse。fetch 的 [Response.body](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 暴漏了[ReadableStream](https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream)类型的 body 内容，下面是一个例子读取 ReadableStream 内容的例子

```typescript
const response = await fetch('https://www.example.org');
let total = 0;

// Iterate response.body (a ReadableStream) asynchronously
for await (const chunk of response.body) {
  // Do something with each chunk
  // Here we just accumulate the size of the response.
  total += chunk.length;
}

// Do something with the total
console.log(total);
```

### node

> node 这里要做几件事情：<1>给页面提供接口，以及对接 openai 提供聊天响应的内容给页面；<2>连接数据库把聊天的内容存储下来，这里用的是 mongodb,驱动库用的是 mongoose，因为 mongoose 自己做类型校验和连接池管理。<3>提供给用户的接口需要做认证，这里用的是 jwt，jwt 生成的 token 由页面保存在 localStorage，每次请求在 header 里都带上 token，用户校验用户。<4>完成后端项目后需要部署，部署的时候使用 pm2 来管理进程，处理错误日志和进程守护。

1.  提供接口用了 Koa 相关库，用的@koa/router 来处理 http 请求。Koa 库的 plugin 支持异步，在 plugin 中需要手动调用下一个插件，所以 Koa 的插件调用是一个洋葱模型：从第一个插件开始，到最后一个插件，然后再回到第一个插件。
<center>
  <img src='./koa_modal1.webp' width="100" height="100" />
  <img src='./koa_modal2.webp' width="100" height="100" />
</center>

2.  连接数据库用的 mongoose，因为设计数据库的时候根据不同种类的信息分为了多个数据库，所以在连接池上的设计是每个数据库都有一个连接池，用完及时关闭，这样可以避免一个数据库的连接池满了影响其他数据库的连接。也增加了效率。下面是 mongoose 一个数据库的基类

    ```typescript
    abstract class Elementary {
      protected dbName: string; // 数据库名
      protected collectionName: string; // 集合名字
      protected uri: string;
      protected connection: Connection | null;
      protected abstract model: Model<any>;
      protected abstract schema: Schema;
      constructor(options: ElementaryOptions) {
        const { dbName, collectionName, uri } = options;
        Object.defineProperties(this, {
          dbName: {
            value: dbName,
            writable: false,
            enumerable: false,
            configurable: false,
          },
          collectionName: {
            value: collectionName,
            writable: false,
            enumerable: false,
            configurable: false,
          },
          uri: {
            value: sanitizeSlashes(`${uri}/${dbName}`),
            writable: false,
            enumerable: false,
            configurable: false,
          },
        });
      }
      connect() {
        const { uri } = this;
        // 创建连接
        // authSource这里代表验证的数据库是什么，一般是admin,在admin里创建各种权限的用户
        this.connection = createConnection(uri, { ...(authSource ? { authSource } : {}) });
        // 创建并连接集合模型
        this.model = this.connection.model(this.collectionName, this.schema);
      }
      checkConnection() {
        if (!this.connection || this.connection.readyState === 0) {
          this.connect();
        }
      }
      async onError(cb: (err: any) => void) {
        this.checkConnection();
        this.connection?.on('error', cb);
      }
      async close() {
        await this.connection?.close();
        this.connection = null;
      }
      async drop() {
        this.checkConnection();
        const { model } = this;
        const number = await model.count();
        // 存在才能删除，否测会报错
        if (number) {
          return await model.collection.drop();
        }
      }
    }
    // 在派生类中执行数据库操作的方法增加这个装饰器，如果数据库连接断开，那么会自动连接
    function preCheckConnection(...arg: any[]) {
      // 装饰器函数
      const [, , descriptor] = arg;
      const originalMethod = descriptor.value;
      descriptor.value = function (...args: any[]) {
        (this as any).checkConnection();
        // @resolve: 如果是异步，那么将返回promise,没有改变函数的返回结果。
        return originalMethod.apply(this, args);
      };
    ```

    常用数据库操作：

    - 简单：增加一条文档：

      ```typescript
      const data = new model(_baseInfo);
      await data.save();
      ```

    - 复杂：给文档里数组增加一条数据，如果有这个文档就插入，如果没有插入数据并设置其他字段：

      ```typescript
      await model.updateOne(
        { uuid: options.uuid },
        {
          $push: { topics: topic }, // 添加到文档的 topics 数组
          $setOnInsert: { uuid: options.uuid }, // 在增加一个文档时设置 uuid.(插入文档时才会生效，和 upsert 联动)
        },
        { upsert: true }, // 没有该文档就增加一个文档
      );
      ```

    - 简单：查询数据：

      ```typescript
      await model.findOne({ email });
      ```

    - 复杂：查询某个文档的 topics 数组字段，并且针对 topics 数组进行排序，并且去掉 topics 中每一项嵌套文档的 messages 字段，最后返回的数据是一个数组，数组的每一项是 topics 数组的每一项，这里用到了 mongodb 的聚合查询：

    ```typescript
    // 聚合通道的任何操作不会改变数据库，只是在内存中变量的变换
    await model.aggregate([
      {
        $match: { uuid }, // 匹配集合里的某个文档
      },
      {
        $unwind: '$topics', //展开topics数组字段，分成多个文档
      },
      {
        $replaceRoot: { // 移动根节点在topics数组拆分成的多个文档
          newRoot: '$topics',
        },
      },
      {
        $sort: { lastUpdateTime: -1 }, // 按时间倒序排序
      },
      {
        $addFields: { // 添加一个字段，$toLong是时间格式转成时间戳, $toString是把ObjectId转成字符串
          lastUpdateTime: { $toLong: '$lastUpdateTime' },
          createTime: { $toLong: '$createTime' },
          id: { $toString: '$_id' },
          messagesCount: { $size: '$messages' },
        },
      },
      {
        $project: {// 投影：确定哪些字段保留，哪些字段丢弃
          _id: 0,
          messages: 0,
        },
      },

    ]);
    }
    ```

    - 简单：更新数据

      ```typescript
      await model.updateOne({ uuid }, { $set: { lastUpdateTime: Date.now() } });
      ```

    - 复杂：更新数据

      ```typescript
      // 需要再次测试
      await model.updateOne(
        {
          uuid,
        },
        {
          $set: {
            'topics.$[topic].messages.$[elem]': newMessage,
          },
        },
        {
          arrayFilters: [
            { 'topic._id': new mongoose.Types.ObjectId(topicId) },
            { 'elem._id': new mongoose.Types.ObjectId(messageId) },
          ],
        },
      );
      ```

3.  认证用户

    > 认证用户的常见几种方式：[OAuth 认证](https://www.rfcreader.com/#rfc6749)，主要用于第三方应用程序认证；Cookie-Session 认证：用户登录后，服务端生成一个 session，然后把 session 的 id 保存在 cookie 里，每次请求都带上 cookie，服务端根据 cookie 里的 session id 找到对应的 session，然后根据 session 里的信息判断用户是否登录；[JWT 认证](https://www.rfcreader.com/#rfc7519)：用户登录后，服务端生成一个 jwt，然后把 jwt 保存在 localStorage 里，每次请求都带上 jwt，服务端根据 jwt 里的信息判断用户是否登录。

    > jwt 的优势是服务端不需要存储凭证，减少了服务端的存储压力，jwt 的缺点是服务端无法主动注销用户，只能等待 jwt 过期，或者用户手动清除 jwt。cookie session 的优势是服务端可以主动注销用户，缺点是服务端需要存储凭证，增加了服务端的存储压力，还有跨域限制，分布式环境同步 session 数据问题。

    基于以上调研使用 jwt. 生成的 demo: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6IjEzNTgzMTA2NzcxQDE2My5jb20iLCJuYW1lIjp7ImZpcnN0TmFtZSI6IuWImCIsImxhc3ROYW1lIjoi5b-X5rSLIn0sInV1aWQiOiJiMWZlZTI5Ny0yMGEwLTQ4MzEtODhlYy0wY2FkM2M2ODYyN2UiLCJpZCI6IjY1NDBiOGY0ZDQ4OGNmZGQ5NWZhNGJkOSIsImlhdCI6MTcwMDQ1MDM3MywiZXhwIjoxNzAwNDUzOTczfQ.nUwSUzSEFUmaCuc9o2BsGbs6ldgFCplIM8RMUf0u1ys`

    - [jwt 介绍](https://jwt.io/introduction)
    - [jwt 解码](https://jwt.io/)

    jwt 生成的 token 包含三部分：header.payload.signature,header 和 payload 都是 json 对象，signature 是对前两部分加上密匙的签名，签名的目的是为了防止 token 被篡改，签名的算法是 header 里的 alg 字段指定的算法，一般是 HMAC SHA256 或者 RSA，这里用的是 HMAC SHA256，签名的时候需要一个密钥，这个密钥只有服务端知道，所以服务端可以根据密钥生成签名，然后把签名和 token 一起返回给客户端，客户端每次请求都带上 token，服务端根据密钥和 token 里的 header 和 payload 生成签名，然后和 token 里的签名比较，如果一样说明 token 没有被篡改，否则说明 token 被篡改了。但是 jwt 最好不要作为敏感信息的凭证，因为 jwt 生成的 payload 部分知识简单的 base64，是可以解码的，所以最好再做一层加密，把加密后的字符串作为 Token 发给客户端。

4.  pm2 部署项目

    - pm2 解决了什么问题：
      - 进程管理： PM2 可以管理 Node.js 应用程序的进程。它确保你的应用在发生崩溃或其他意外情况时能够重新启动，保持应用的高可用性。
      - 自动重启： 如果 Node.js 应用程序由于错误或其他原因崩溃，PM2 会自动重新启动应用程序，确保应用的稳定性。
      - 日志管理： PM2 可以集中管理应用程序的日志，使得查找和分析日志更加方便。你可以通过 PM2 命令查看实时日志、历史日志等。
      - 负载均衡： PM2 支持多进程模式，可以将请求分发到多个 Node.js 进程中，以提高应用程序的性能和吞吐量。
      - 部署简化： PM2 可以帮助你简化应用程序的部署过程。你可以使用 PM2 部署命令轻松地将应用程序部署到服务器上。
      - 运行时信息： PM2 提供了一个用户友好的仪表板，可以查看所有 Node.js 应用程序的运行时信息，包括 CPU 使用率、内存使用情况等。
    - pm2 常用命令：
      - 启动命令：pm2 start ecosystem.config.js
      - 修改配置参数重启命令：pm2 reload ecosystem.config.js && pm2 restart all
      - 暂停命令：pm2 stop server_name
      - 删除命令：pm2 delete server_name
      - 查看日志命令：pm2 logs server_name
      - 查看运行状态命令：pm2 status
      - 查看所有进程命令：pm2 list
      - 查看所有进程的运行状态命令：pm2 monit
    - pm2 日志系统：主要使用 pm2-logrotate 模块，pm2-logrotate 模块可以帮助我们管理日志，它可以将日志按照时间进行切割，防止日志文件过大，还可以将日志文件压缩，节省磁盘空间。

      - 安装：pm2 install pm2-logrotate
      - pm2 set pm2-logrotate:compress true # 开启日志文件压缩
      - pm2 set pm2-logrotate:retain 7 # 保留最近 7 天的日志文件
      - pm2 set pm2-logrotate:rotateInterval '0 0 \* \* \*' # 每天凌晨 0 点切割日志

    - pm2 的配置：pm2 的配置文件是 ecosystem.config.js，配置文件的内容如下：

      ````javascript
      module.exports = {
        apps: [{
        name: 'chat_server',
        script: './main.cjs',
        env: { // 用于指定应用程序的环境变量，可以在应用程序中通过 process.env 访问
          OPENAI_API_KEY: process.env.OPENAI_API_KEY,
          OPENAI_API_KEY_35: process.env.OPENAI_API_KEY_35,
          OPENAI_API_KEY_40: process.env.OPENAI_API_KEY_40,
        },
        // 可以启动多个实例来处理高并发，暂时没有用到高并发，所以写了一个实例
        instances: 1,
        // 如果超出最大内存限制，自动重启应用程序
        max_memory_restart: '300M',
        // 设置应用程序异常退出重启的次数，默认 15 次（从 0 开始计数）；
        max_restarts: 3,
        // 避免一直重启，设置指数退避重启延迟：在重启几次后，就延迟重启
        exp_backoff_restart_delay: 15000,
        /**日志参数-start */
        out_file: './logs/out_file.log', // 文件路径一定要设置
        error_file: './logs/error_file.log',
        time: true, // 日志前加上时间
        merge_logs: true, // 用于在运行多个进程时，将日志文件合并到一个文件中
        log_date_format: 'YYYY-MM-DD HH:mm Z',
        /**日志参数-end */
        }],
      };
      ```
      ````

    - pm2 的日志文件：pm2 的日志文件是在项目根目录下的 logs 文件夹里，日志文件的命名规则是：out_file.log、error_file.log，其中 out_file.log 是标准输出日志，error_file.log 是错误日志。

5.  nginx 代理项目

    - nginx 解决了什么问题：
      > 本项目由于只有一台服务器，所以只用到了 nginx 反向代理，静态文件服务，url 重写，https 证书校验。
      - 高并发和性能： Nginx 被设计用来处理大量并发连接，能够高效地处理数千个同时活跃的连接。这对于高流量的网站和应用程序至关重要。
      - 反向代理： Nginx 可以作为反向代理服务器，接收客户端请求，并将这些请求转发到后端服务器。这有助于负载均衡、提高应用程序的可用性和性能。
      - 负载均衡： Nginx 可以平衡多个后端服务器的负载，确保请求分散到各个服务器，从而防止某一台服务器过载。
      - 静态文件服务： Nginx 对于提供静态文件（如 HTML、CSS、JavaScript、图像等）非常高效，通过直接返回这些文件而不涉及后端应用程序的处理。
      - SSL/TLS 终结： Nginx 能够处理 SSL/TLS 终结，减轻后端服务器的负担，提高安全性。
      - 反向代理缓存： Nginx 可以缓存动态内容的快照，以降低对后端服务器的请求，提高响应速度。
      - URL 重写： Nginx 允许对 URL 进行灵活的重写和重定向，有助于优化 URL 结构和改进搜索引擎优化（SEO）
    - 配置 SSL 证书，升级 https 访问

      - 购买 SSL 证书，绑定域名
      - 安装 nginx 后配置 nginx.conf

        ```yaml
        server {
          listen 80;
          server_name qunyangbang.cn www.qunyangbang.cn;
          root /www/wwwroot; # 重定向所有 HTTP 请求到 HTTPS
          #不写301是因为这里还代理了接口服务，301会把post重定向为get请求，307则不会
          return 307 https://$server_name$request_uri;

        }
          server {
              #SSL 默认访问端口号为 443
              listen 443 ssl;
              #请填写绑定证书的域名
              server_name qunyangbang.cn;
              #请填写证书文件的相对路径或绝对路径
              ssl_certificate /www/server/panel/vhost/cert/qunyangbang.cn_bundle.crt;
              #请填写私钥文件的相对路径或绝对路径
              ssl_certificate_key /www/server/panel/vhost/cert/qunyangbang.cn.key;
              ssl_session_timeout 5m;
              #请按照以下协议配置
              ssl_protocols TLSv1.2 TLSv1.3;
              #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。
              ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;
              ssl_prefer_server_ciphers on;
              location / {
                  root /www/wwwroot;
                  index  index.html index.htm;
              }
          }
        ```

    - 配置接口代理和静态资源代理

      ```yaml
        server {
          listen 80;
          # 这个证书是单域名的
          server_name qunyangbang.cn www.qunyangbang.cn m.qunyangbang.cn;
          root /www/wwwroot;
          # 重定向所有 HTTP 请求到 HTTPS
            return 307 https://$server_name$request_uri;

        }
        server {
            #SSL 默认访问端口号为 443
            listen 443 ssl;
            #请填写绑定证书的域名,这个证书是单域名的
            server_name qunyangbang.cn www.qunyangbang.cn;
            #请填写证书文件的相对路径或绝对路径
            ssl_certificate /www/server/panel/vhost/cert/qunyangbang.cn_bundle.crt;
            #请填写私钥文件的相对路径或绝对路径
            ssl_certificate_key /www/server/panel/vhost/cert/qunyangbang.cn.key;
            ssl_session_timeout 5m;
            #请按照以下协议配置
            ssl_protocols TLSv1.2 TLSv1.3;
            #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。
            ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;
            # 优先使用服务器端定义的加密套件，而不是客户端定义的加密套件
            ssl_prefer_server_ciphers on;
            location / {
                root /www/wwwroot;
                index  index.html index.htm;
            }
            # chat项目的后端
            location ^~ /chat_server/ {
              proxy_pass http://127.0.0.1:4001/;
            }
            # chat项目的前端
            location /chat_web/ {
              alias /www/wwwroot/chat/chat_web/;
              autoindex on;
              try_files $uri $uri/ /chat_web/index.html;
            }
        }
      ```

6.  mongodb 使用

    - 安装：登录[官网下载](https://www.mongodb.com/try/download/community),然后解压到指定目录
    - 设置 data 和 log 目录
    - 设置 mongodb.conf 文件

      ```yaml
      # 设置数据文件的存放目录
      storage:
        dbPath: ../data

      # 设置日志文件的存放目录及其日志文件名
      systemLog:
        destination: file
        path: ../logs/mongodb.log
        # 分割日志文件的方式是重新打开
        logRotate: reopen
        #追加日志在后面
        logAppend: true
        #日志等级，分为0,1,2,3,4,5，约高越详细
        verbosity: 0

      # 设置端口号（默认的端口号是 27017）
      net:
        port: 27017
        bindIp: 0.0.0.0

      # 启用身份验证
      security:
        authorization: enabled

      setParameter:
        enableLocalhostAuthBypass: 0

      #设置为以守护进程的方式运行
      processManagement:
        fork: true
      ```

    - 启动：./bin/mongod -f ./mongodb.conf
    - node 连接： 开启身份验证，需要传入 authSource，一般是 admin，然后在 admin 里创建用户，然后用这个用户连接数据库

      ```typescript
      const uri = `mongodb://${user}:${password}@${host}:${port}/${dbName}?authSource=${authSource}`;
      ```

    - mongodb Compass 连接：mongodb Compass 是 mongodb 官方提供的可视化工具，可以用来连接 mongodb 数据库，管理数据库，导入导出数据等等。[下载地址](https://www.mongodb.com/try/download/compass)

7.
